# 算法学习

## 第一章 贪心算法


贪心算法保证==每次操作都是局部最优的==,从而使最后得到的结果是==全局最优的==。

使用贪心算法需要保证==全局结果是局部结果的简单求和，且局部结果互不相干==，以保证局部最优的策略也同样是全局最优的策略。



1. 分配问题
2. 区间问题


## 第二章 双指针

双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。

若两个指针指向同一数组，遍历方向相同且不会相交，则也称为==滑动窗口==(两个指针包围的区域即为当前的窗口)，常用于区间搜索。

若两个指针指向同一数组，但是遍历方向相反，则可以用来搜索，待搜索的数组往往是排序好的

1. 指针与const
2. 指针函数与函数指针

## 第三章 二分查找

对长度为```O(n)```的数组，二分查找的时间复杂度为```O(log n)```
二分查找时，区间的左右段没有严格的要求，可以：
1. 左闭右开 满足C++、Python等语言的习惯
2. 左闭右闭 便于处理边界条件
双指针通常是一步一步移动，二分查找里指针每次移动半个区间的长度。



## 第四章 排序算法

## 第五章 深度优先搜索与广度优先搜索

## 第六章 动态规划

## 第七章 分治算法

## 第八章 数学问题

## 第九章 位运算

## 第十章 数据结构


#### C++ STL

1. Sequence Containers： 维持顺序的容器
    (a). vector(动态数组):    随机读取以及尾部增删的复杂度都是```O(1)```
    (b). list(双向链表):    也可以当作 stack 和 queue 来使用
    (c). deque(双端队列):    既支持```O(1)```随机读取，又支持```O(1)```时间的头部增删和尾部增删，不过有一定的额外开销。
    (d). array(定长数组)
    (e). forward_list(单向链表)

2. Container Adaptors：基于其它容器实现的数据结构
    (a). stack： 后入先出（LIFO） 的数据结构，默认基于 deque 实现。 stack 常用于深度优先搜索、一些字符串匹配问题以及单调栈问题。
    (b). queue： 先入先出（FIFO） 的数据结构，默认基于 deque 实现。 queue 常用于广度优先搜索。
    (c). priority_queue： 最大值先出的数据结构，默认基于vector实现堆结构。它可以在```O(nlogn)```的时间排序数组，```O(logn)```的时间插入任意值，```O(1)```的时间获得最大值，```O(logn)```的时间删除最大值。 priority_queue 常用于维护数据结构并快速获取最大或最小值。

3. Associative Containers：实现了排好序的数据结构。
    (a). set： 有序集合，元素不可重复，底层实现默认为红黑树，即一种特殊的二叉查找树（BST）。它可以在 ```O(nlogn)```的时间排序数组， ```O(logn)```的时间插入、删除、查找任意值， ```O(logn)```的时间获得最小或最大值。这里注意， set 和 priority_queue 都可以用于维护数据结构并快速获取最大最小值，但是它们的时间复杂度和功能略有区别，如priority_queue 默认不支持删除任意值，而 set 获得最大或最小值的时间复杂度略高，具体使用哪个根据需求而定。
    (b). multiset：支持重复元素的 set。
    (c). map： 有序映射或有序表，在 set 的基础上加上映射关系，可以对每个元素 key 存一个值 value。
    (d). multimap：支持重复元素的 map。
4. Unordered Associative Containers：对每个 Associative Containers 实现了哈希版本。
    (a). unordered_set： 哈希集合，可以在 O„1” 的时间快速插入、查找、删除元素，常用于快速的查询一个元素是否在这个容器内。
    (b). unordered_multiset：支持重复元素的 unordered_set。
    (c). unordered_map： 哈希映射或哈希表，在 unordered_set 的基础上加上映射关系，可以对每一个元素 key 存一个值 value。在某些情况下，如果 key 的范围已知且较小，我们也可以用 vector 代替 unordered_map，用位置表示 key，用每个位置的值表示 value。
    (d). unordered_multimap：支持重复元素的 unordered_map。

#### 数组

#### 栈和队列

#### 单调栈

#### 优先队列

#### 双端队列

#### 哈希表

#### 多重集合和映射

#### 前缀和 与 积分图













## 查找算法

#### 顺序查找

#### 二分查找

#### 插值查找

#### FIbonacci查找

#### 分块查找

#### 树表查找

#### HashTable查找








## 排序算法
排序算法可分为内部排序和外部排序。其中内部排序有五大类:插入排序，选择排序，交换排序，归并排序，基数排序。
#### 插入排序

##### 1. 直接插入排序
##### 2. 其他插入排序
##### 3. 希尔排序

#### 交换排序

##### 1. 冒泡排序
##### 2. 快速排序

#### 选择排序

##### 1. 简单选择排序
##### 2. 树形选择排序
##### 3. 堆排序

#### 归并排序

#### 基数排序

##### 1. 多关键字的排序
##### 2. 链式基数排序


