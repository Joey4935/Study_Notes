# 算法学习

## 第一章 贪心算法


贪心算法保证==每次操作都是局部最优的==,从而使最后得到的结果是==全局最优的==。

使用贪心算法需要保证==全局结果是局部结果的简单求和，且局部结果互不相干==，以保证局部最优的策略也同样是全局最优的策略。

1. 分配问题
2. 区间问题


## 第二章 双指针

双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。

若两个指针指向同一数组，遍历方向相同且不会相交，则也称为==滑动窗口==(两个指针包围的区域即为当前的窗口)，常用于区间搜索。

若两个指针指向同一数组，但是遍历方向相反，则可以用来搜索，待搜索的数组往往是排序好的

1. 指针与const
2. 指针函数与函数指针

## 第三章 二分查找

对长度为```O(n)```的数组，二分查找的时间复杂度为```O(log n)```
二分查找时，区间的左右段没有严格的要求，可以：
1. 左闭右开 满足C++、Python等语言的习惯
2. 左闭右闭 便于处理边界条件
双指针通常是一步一步移动，二分查找里指针每次移动半个区间的长度。



## 第四章 排序算法

## 第五章 深度优先搜索与广度优先搜索

## 第六章 动态规划

## 第七章 分治算法

## 第八章 数学问题

## 第九章 位运算

## 第十章 数据结构


#### C++ STL

1. Sequence Containers： 维持顺序的容器
    (a). vector(动态数组):    随机读取以及尾部增删的复杂度都是```O(1)```
    (b). list(双向链表):    也可以当作 stack 和 queue 来使用
    (c). deque(双端队列):    既支持```O(1)```随机读取，又支持```O(1)```时间的头部增删和尾部增删，不过有一定的额外开销。
    (d). array(定长数组)
    (e). forward_list(单向链表)

2. Container Adaptors：基于其它容器实现的数据结构
    (a). stack： 后入先出（LIFO） 的数据结构，默认基于 deque 实现。 stack 常用于深度优先搜索、一些字符串匹配问题以及单调栈问题。
    (b). queue： 先入先出（FIFO） 的数据结构，默认基于 deque 实现。 queue 常用于广度优先搜索。
    (c). priority_queue： 最大值先出的数据结构，默认基于vector实现堆结构。它可以在```O(nlogn)```的时间排序数组，```O(logn)```的时间插入任意值，```O(1)```的时间获得最大值，```O(logn)```的时间删除最大值。 priority_queue 常用于维护数据结构并快速获取最大或最小值。

3. Associative Containers：实现了排好序的数据结构。
    (a). set： 有序集合，元素不可重复，底层实现默认为红黑树，即一种特殊的二叉查找树（BST）。它可以在 ```O(nlogn)```的时间排序数组， ```O(logn)```的时间插入、删除、查找任意值， ```O(logn)```的时间获得最小或最大值。这里注意， set 和 priority_queue 都可以用于维护数据结构并快速获取最大最小值，但是它们的时间复杂度和功能略有区别，如priority_queue 默认不支持删除任意值，而 set 获得最大或最小值的时间复杂度略高，具体使用哪个根据需求而定。
    (b). multiset：支持重复元素的 set。
    (c). map： 有序映射或有序表，在 set 的基础上加上映射关系，可以对每个元素 key 存一个值 value。
    (d). multimap：支持重复元素的 map。
4. Unordered Associative Containers：对每个 Associative Containers 实现了哈希版本。
    (a). unordered_set： 哈希集合，可以在 O„1” 的时间快速插入、查找、删除元素，常用于快速的查询一个元素是否在这个容器内。
    (b). unordered_multiset：支持重复元素的 unordered_set。
    (c). unordered_map： 哈希映射或哈希表，在 unordered_set 的基础上加上映射关系，可以对每一个元素 key 存一个值 value。在某些情况下，如果 key 的范围已知且较小，我们也可以用 vector 代替 unordered_map，用位置表示 key，用每个位置的值表示 value。
    (d). unordered_multimap：支持重复元素的 unordered_map。

#### 数组

#### 栈和队列

#### 单调栈

#### 优先队列

#### 双端队列

#### 哈希表

#### 多重集合和映射

#### 前缀和 与 积分图













## 查找算法

#### 顺序查找

#### 二分查找

#### 插值查找

#### FIbonacci查找

#### 分块查找

#### 树表查找

#### HashTable查找








## 排序算法
###### 排序算法的分类

+ 按排序是否建立在关键字比较上进行区分：
    1. 基于比较的排序
    2. 不基于比较的排序

+ 按排序过程中的不同原则进行区分：
    1. 插入排序
    2. 交换排序
    3. 选择排序
    4. 归并排序
    5. 基数排序

+ 按排序过程中需要的工作量进行区分：
    1. 简单排序法 $O(n^2)$
    2. 先进排序法 $O(n\log_{2}^{ }n)$
    3. 基数排序法 $O(d \times n)$  其中d为单逻辑关键字中关键字的个数

+ 待排序记录的数据类型：

```

struct SqList
{
    int *r;     //基址，建表时按实际值分配;
    int length; //表长
};

```

#### 插入排序
插入排序(Insertion Sort)，基本思想为：每次将一个待排记录按其关键字大小插入到一个已安排好的有序子序列中，直到全部记录排好顺序。

##### 1. 直接插入排序
直接插入排序(Straight Insertion Sort)是插入排序中最简单的一种排序方法。

+ 关键问题：
1).如何构造初始有序子序列。
2).如何查找待插记录插入位置。

+ 算法设计：
1).  构造初始的有序子序列。
将n个待排序的记录序列:$ \{ r_1 , r_2, ... ,r_n\}$划分成有序区和无序区，初始化时==有序区为待排序记录序列中的第一个记录==，无序区包括所有剩余待排序区的记录。
2).  查找待插入记录的插入位置。
依次将无序区中的记录与有序区中记录关键字比较，确定插入位置并插入记录，从而使无序区减少一个记录，有序区增加一个记录；重复该过程，直到无序区中没有记录。

+ 算法描述：
```
void SortAlgorithm::StraightInsertionSort(SqList & l_Data)
{
	//遍历无序序列
	int j = 0;
	for (int i = 1; i < l_Data.length; ++i)	//遍历整个顺序表
	{
		if (l_Data.r[i] < l_Data.r[i - 1])
		{
			//临时保存将要排序的元素 
			int tmp = l_Data.r[i];
			//遍历有序序列
			for (j = i - 1; (tmp < l_Data.r[j]) && (j >= 0); j--)
			{   
                            //待排序元素 小于 有序序列中当前元素时 将该元素后移
			    l_Data.r[j + 1] = l_Data.r[j];
			}
			//待排序元素 大于 有序序列最后一个元素 直接将该元素插入到有序序列最后
			l_Data.r[j + 1] = tmp;
		}
	}
	return;
}
```
注意插入时的边界条件。

+ 总结：
简单插入排序是一种稳定的排序方法，简单且容易实现，当序列中的记录==基本有序==或者==待排序记录较少==时，他是最佳方法。但当待排序的记录个数较多时，大量的移动操作使直接插入排序算法的效率降低。
该算法的时间复杂度：$O(n^2)$，空间复杂度：$O(1)$

##### 2. 希尔排序
希尔排序(Shell Sort)又称最小增量排序，是对直接插入排序的改进算法。其基本思想是先将整个待排序记录序列分割成若干个子序列，在子序列内分别进行直接插入，待整个序列基本有序时，再对全体记录进行一次直接插入排序。

+ 关键问题：
1). 如何分割待排序记录，才能保证整个序列逐步向基本有序发展。
2). 子序列内如何进行直接插入排序。

+ 算法设计：
1). 分割待排序记录。
    将相聚某个“增量”的记录组成一个子序列，这样才能有效地保证在子序列内分别进行直接插入排序后得到的结果是==基本有序==而不是==局部有序==。增量一般取：$d_1 = \lfloor n/2 \rfloor , d_{i+1} = \lfloor d_i/2 \rfloor$,且没有除1之外的公因子，并且最后一个增量必须等于1。
2). 在子序列内进行直接插入排序。


+ 算法描述：

```
void ShellSort(SqList &l_Data)
{
	int dk = l_Data.length / 2;
	while (dk != 0)
	{
		ShellInsert(l_Data, dk);
		dk = dk / 2;
	}
	return;
}

void ShellInsert(SqList &l_Data ,int d)
{
	//对顺序表L做一趟希尔插入排序，前后增量是d；L.r[0]只作为暂存单元
	for (int i = 0; i < d; i++)
	{
		//插入排序
		for (int j = d + i; j < l_Data.length; j += d)
		{
			if (l_Data.r[j] < l_Data.r[j - d])
			{
				int tmp = l_Data.r[j];
				int k = 0;
				for (k = j - d; (tmp < l_Data.r[k]) && (k >= 0); k -= d)
				{
					//待排序元素 小于 有序序列中当前元素时 将该元素后移
					l_Data.r[k + d] = l_Data.r[k];
				}
				//待排序元素 大于 有序序列最后一个元素 直接将该元素插入到有序序列最后
				l_Data.r[k + d] = tmp;
			}
		}
	}
	return;
}
```

+ 总结：
希尔排序是一种分组插入排序，平均时间复杂度为 $O(n\log_{2}^{ }n)$，空间复杂度为$O(1)$,该算法是一种不稳定排序方法，该方法简单且易于实现，其性能在待排记录数目较多时更能得到充分发挥。
##### 3. 其他插入排序
。。。


#### 交换排序
交换排序(Exchange Sort)是一类借助“交换”进行排序的方法，其基本思想是：在待排序序列中选择两个记录，将它们的关键字进行比较，如果反序则交换他们的位置。
##### 1. 冒泡排序
冒泡排序(Bubble Sort)是交换排序中最简单的一种排序方法。
+ 关键问题：
    1). 确定待排序记录的范围

    2). 判断冒泡排序的结束

+ 算法设计：


+ 算法描述：
```
void BubbleSort(SqList &L)
{
    //对顺序表L作冒泡排序
    int tag = 0;                            //设置标志tag
    for(int bound = 0;tag == 0; ++bound)
    {
        tag = 1;
        for(int i = n - 1; i > bound; --i)  //一趟冒泡排序
        {
            if(L.r[i+1].key < L.r[i].key)
            {
                //交换
                L.r[0] = L.r[i+1];
                L.r[i+1] = L.r[i];
                L.r[i] = L.r[0];
                tag = 0;
            }
        
        }
    }
}
```
+ 总结：


##### 2. 快速排序

快速排序(Quick Sort)又称划分交换排序，是对冒泡排序的改进。

+ 关键问题：
    1). 选取轴记录
    2). 在排序记录序列中进行分区
    3). 对两个排序记录子序列分别快速排序
+ 算法设计：

```

```


+ 算法描述：



+ 总结：

#### 选择排序
选择排序(Selection Sort)是一类借助“选择进行排序的方法”，其基本思想是：==每趟排序在当前待排序序列中选择出关键字最小的记录，添加到有序序列中==。比较次数较多，移动次数少。
##### 1. 简单选择排序
简单选择排序(Simple Selection Sort)

+ 关键问题：
    1). 在待排序序列中选出关键字最小的记录。
    2). 确定待排序序列中关键字最小的记录在有序序列中的位置。
+ 算法设计：

```

```


+ 算法描述：



+ 总结：
##### 2. 树形选择排序

##### 3. 堆排序

#### 归并排序

#### 基数排序


##### 1. 多关键字的排序
##### 2. 链式基数排序


